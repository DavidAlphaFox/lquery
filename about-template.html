<!--
  This file is a part of lQuery
  (c) 2014 TymoonNET/NexT http://tymoon.eu (shinmera@tymoon.eu)
  Author: Nicolas Hafner <shinmera@tymoon.eu>
  !-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>lQuery - About</title>
    <style type="text/css">
      code{font-family: Consolas, Inconsolata, monospace;}
      h3{display: inline-block;margin:0;padding:0;}
      .version-diff{color:red;}
      .docs{list-style: none;}
      .docs li{margin-bottom: 20px;}
      .docs pre{margin: 0 0 0 10px; white-space: pre-wrap;}
    </style>
  </head>
  <body>
    <header>
      <img src="lquery-logo.png" alt="lQuery"/>
      <h1>v2.0.0</h1>
    </header>
    <div id="content">
      <article>
        <header><h2>What is lQuery?</h2></header>
        <p>
          lQuery is a DOM manipulation library written in Common Lisp, inspired by and based on the <a href="http://jquery.com/">jQuery</a> syntax and functions. It uses <a href="http://common-lisp.net/project/cxml/">Closure-XML</a> and <a href="https://github.com/AccelerationNet/css-selectors">CSS-Selectors</a> in the background to achieve its work. Its main idea is to replace HTML templating systems and allow generated HTML for websites while relying on pure HTML files. This achieves a much cleaner separation of static and dynamic page parts.
        </p>
      </article>
      <article>
        <header><h2>How To</h2></header>
        <p>
          Load lQuery with ASDF or Quicklisp.
        </p>
        <code>(ql:quickload :lquery)</code>
        <p>
          First, lQuery needs to be initialized with a document to work on:
        </p>
        <code>($ (initialize #p"/path/to/input.html"))</code>
        <p>
          After that, you can use the $ function to select and manipulate the DOM:
        </p>
        <code>($ "article")</code><br />
        <code>($ "article" (add-class "fancy") (attr :foo "bar"))</code>
        <p>
          To render the HTML to a string use <code>serialize</code>. If you want to save it to a file directly, there's also <code>write-to-file</code>.
        </p>
        <code>($ (serialize))</code><br />
        <code>($ (write-to-file #p"/path/to/output.html"))</code>
        <p>
          So a quick file manipulation could look something like this:
        </p>
        <code>($ (initialize #p"/path/to/input.html") "article" (append-to "content") (add-class "foo") (write-to-file #p"/path/to/output.html"))</code>
        <p>
          Aside from using selectors as the first step, it's also possible to use any other variable or list and operate on it.
          <span class="version-diff">Since 2.0</span>: Literal function calls need to be added with (inline).
          Note that the result of the inline function will be used as if literally put in place. For example, an inlined function that evaluates
          to a string will result in a CSS-select.
        </p>
        <code>($ (inline (list node-a node-b)) "article" (serialize))</code>
        <p>
          Selectors can come at any point in the sequence of lQuery operations and will always act on the current set of elements.
          If an operation evaluates to a list or a single node, the current set of elements is set to this result.
        </p>
        <code>($ "a" (text "Link") ($ "p") (text "Paragraph"))</code>
        <p>
          This is equivalent to the following:
        </p>
        <code>($ "a" (text "Link"))</code><br />
        <code>($ "p" (text "Paragraph"))</code>
        <p>
          While this sort of chaining is possible, it is discouraged and multiple statements should be used instead to ensure proper readability.
        </p>
        <p>
          Functions in the argument list will be translated to a function invocation with the current list of elements as their argument.
        </p>
        <code>($ "a" #'(lambda (els) (first els)))</code>
        <p>
          lQuery<sup class="version-diff">Since 2.0</sup> also supports compile-time evaluation of forms, whose results are then put in place of their function calls:
        </p>
        <code>($ (eval (format NIL "~a" *selector*)))</code>
        <p>
          Keep in mind that the lexical environment is not the same at compile-time as at run-time.
        </p>
      </article>
      <article>
        <header><h2>Extending lQuery <sup class="version-diff">For 2.0</sup></h2></header>
        <p>
          lQuery allows extension in a couple of ways. The most important of which are node operations themselves, which come in two flavours: node-funs and node-list-funs.
          Any node operation resides in the package :lquery-funcs, which is automatically scanned by the $ macro. The two macros responsible for defining new node functions automatically
          place the resulting operations in this package for you.
        </p>
        <code>(define-node-function name (node-name &amp;rest arguments) &amp;optional docstring &amp;body body)</code><br />
        <code>(define-node-list-function name (list-name &amp;rest arguments) &amp;optional docstring &amp;body body)</code>
        <p>
          Any function generated by these macros can be called either with a single node or a list of nodes. In the case of a regular node operation, if it receives a list of nodes, the
          function is called once for each node and the results are collected into a list, which is then returned. If it receives a single node, only a single result is returned. In the
          case of a node list function, the return value can be either a list or a single value, depending on what the goal of the operation is.
        </p>
        <p>
          The $ macro itself can be extended as well by providing additional argument- or symbol-handlers. The following two macros make this possible:
        </p>
        <code>(define-argument-handler type (argsname nodesname) &amp;body body)</code>
        <p>
          Argument handlers transform the arguments at compile-time. For example, this would allow an extension to turn literal arrays into lists so they can be processed as well.
        </p>
        <code>(define-symbol-handler type (symbolname nodesname) &amp;body body)</code>
        <p>
          Symbol handlers on the other hand determine the action at run-time. This is mostly useful for defining special actions on certain variable values.
        </p>
      </article>
      <article>
        <header><h2>Other Guff</h2></header>
        <p>
          lQuery is a sub-project of TyNETv5 ("Radiance"), licensed under the <a href="http://opensource.org/licenses/Artistic-2.0">Artistic License 2.0</a> and &#169;2013 TymoonNET/NexT, <a href="http://shinmera.com">Nicolas Hafner</a>.<br />
          This library can be obtained via git on <a href="https://github.com/Shinmera/lquery.git">https://github.com/Shinmera/lquery.git</a>. For questions, patches or suggestions, please contact me via <a href="mailto:shinmera@tymoon.eu">email</a> or write a <a href="https://github.com/Shinmera/lquery/issues">github issue</a>.
        </p>
      </article>
      <article>
        <header><h2>lQuery Package Function Index</h2></header>
        <ul id="docs" class="docs">
          <li id="template">
            <a name="" class="anchor"></a>
            <article>
              <header>
                <span class="functype">test</span>
                <code>
                  <h3 class="funcname">Foo</h3>
                  <span class="funcargs">()</span>
                </code>
              </header>
              <pre class="funcdesc">
                Foobar
              </pre>
            </article>
          </li>
        </ul>
      </article>
      <article>
        <header><h2>lQuery-Funcs Package Function Index</h2></header>
        <ul id="func-docs" class="docs">
        </ul>
      </article>
    </div>
  </body>
</html>
